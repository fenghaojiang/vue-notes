---
title: 原型模式  
date: 2021-07-29
---  


我们创建的每个函数都有一个原型prototype(原型)属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。  

让所有对象实例共享它所包含的属性和方法。不必再构造函数中定义对象实例的信息，而是添加到原型对象中。   

```js
function Person() {

}
Person.prototype.name = "NIKO";
Person.prototype.age = 29;
Person.prototype.sayName = function() {
    alert(this.name);
};

var person1 = new Person();
person1.sayName(); //NIKO
var person2 = new Person();
alter(person1.sayName == person2.sayName);//true
```

```js
alter(Person.prototype.isPrototypeOf(person1)); //true
alter(Person.prototype.isPrototypeOf(person2)); //true
```

内部都有指向Person.prototype的指针，因此都返回了true  

ECMAScript5增加了一个新方法  
```js
alert(Object.getPrototypeOf(person1) == Person.prototype); //true
alert(Object.getPrototypeOf(person1).name); //NIKO
```

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果再实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针只想的原型对象，在原型对象中查找具有给定名字的属性。  

```js
function Person() {

}
Person.prototype.name = "NIKO";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    alert(this.name);
};

var person1 = new Person();
var person2 = new Person();

person1.name = "qiezi";
alert(person1.name); //qiezi——————来自实例
alert(person2.name); //NIKO——————来自原型

delete person1.name;
alert(person1.name);  //NIKO  
``` 

delete操作符删除了person1.name后，恢复了对原型中的name属性的连结。  


使用hasOwnProperty()方法可以检测一个属性是存在于实例中还是原型中。这个方法只在给定属性存在于对象实例中时，才会返回true  



